# Hardworker Marketplace 분석 요약

**문서 버전:** 1.1
**날짜:** 2026-01-09
**분석 범위:** 아키텍처, 상태 관리, 훅, 에이전트, 코드 품질 전체 분석

**변경 로그:**
- v1.1 (2026-01-09): ultrawork v0.1.0 반영 - gate-status-notification hook 추가, 총 7개 훅

---

## 요약

hardworker-marketplace 플러그인 시스템을 5가지 핵심 영역(아키텍처 패턴, 상태 관리, 훅 시스템, 에이전트 위임, 코드 품질)에서 종합적으로 평가했습니다. 시스템은 정교한 에이전트 조율, 증거 기반 검증, 명확한 관심사 분리를 통해 **탄탄한 아키텍처 기반**을 보여줍니다.

**전체 시스템 상태: 양호 (82/100)**

| 영역 | 점수 | 상태 |
|------|------|------|
| 아키텍처 | 90/100 | ✅ 우수 |
| 상태 관리 | 75/100 | ⚠️ 양호(개선 필요) |
| 훅 시스템 | 95/100 | ✅ 우수 |
| 에이전트 패턴 | 85/100 | ✅ 우수 |
| 코드 품질 | 85/100 | ✅ 양호 |

### 핵심 강점

1. **명확한 아키텍처:** 엄격한 Command → Agent → Script → State 분리로 단일 책임 원칙 적용
2. **정교한 훅:** 7개의 라이프사이클 훅이 에이전트 로직을 오염시키지 않고 자동 증거 수집 및 게이트 상태 알림
3. **에이전트 전문화:** 목적에 맞게 설계된 에이전트(explorer, planner, worker, verifier)로 토큰 사용량 및 도구 접근 최적화
4. **높은 코드 품질:** 100% Bash 표준 준수, 구문 오류 없음, 일관된 패턴
5. **세션 격리:** 고유한 세션 디렉토리로 세션 간 간섭 방지

### 중요 개선점

1. **경쟁 조건:** teamwork의 태스크 클레임에 check-then-set 경쟁 조건 존재 (영향도 높음)
2. **일관성 없는 락킹:** 파일 락킹 메커니즘이 있지만 변경 스크립트에서 일관되게 사용되지 않음
3. **테스트 부재:** 자동화된 테스트 스위트 없음 (수동 테스트만)
4. **문자열 이스케이핑:** task-update.sh의 sed 기반 이스케이핑이 인젝션 위험 생성

### 비즈니스 영향

**긍정적:**
- 멀티 에이전트 워크플로우가 복잡한 작업에 확장 가능
- 증거 기반 검증이 불완전한 작업 감소
- 세션 격리로 동시 개발 가능
- 훅 시스템이 품질 검사 자동화

**위험 영역:**
- 동시 태스크 클레임이 중복 작업 유발 가능 (중간 확률)
- 높은 동시성에서 상태 손상 가능 (현재 사용 패턴에서 낮은 확률)
- 자동화된 회귀 감지 없음 (테스트 부재)

---

## 영역별 주요 발견사항

### 1. 아키텍처 패턴

**분석 출처:** docs/analysis/architecture-patterns.md

#### 핵심 흐름

```
사용자 입력 → 커맨드 → 오케스트레이터 에이전트
                         ↓
                    탐색기 (병렬)
                         ↓
                    플래너 (auto 모드만)
                         ↓
                    워커 (의존성에 따라 병렬)
                         ↓
                    검증기 (최종 게이트키퍼)
```

#### 식별된 주요 패턴

| 패턴 | 구현 | 이점 |
|------|------|------|
| **선언적 커맨드** | YAML frontmatter가 포함된 마크다운 | 사람이 읽기 쉽고, AI가 파싱 가능 |
| **에이전트 전문화** | ultrawork 5개, teamwork 9개 에이전트 | 최적화된 도구 접근, 집중된 프롬프트 |
| **스크립트 소유 상태** | jq를 사용한 Bash 스크립트 | 런타임 의존성 없음, 원자적 연산 |
| **세션 격리** | 세션별 UUID 디렉토리 | 안전한 동시 실행 |
| **백그라운드 + 폴링** | run_in_background와 TaskOutput | 사용자 인터럽트 가능 |

#### 강점

1. **관심사 분리:** 각 계층이 단일 책임을 가짐
2. **에이전트 내 구현 없음:** 에이전트는 스크립트에 위임, 직접 구현하지 않음
3. **일관된 표준:** plugin.json, AGENT.md, 스크립트 규약 적용
4. **명확한 경계:** 도구 접근 매트릭스가 에이전트의 패턴 우회 방지

#### 개선점

1. **플러그인 간 의존성 없음:** 플러그인이 완전히 격리됨 (의도적 설계)
2. **수동 모델 선택:** 오케스트레이터가 태스크별로 haiku/sonnet/opus 선택 필요

### 2. 상태 관리

**분석 출처:** docs/analysis/state-management.md

#### 상태 스키마 목록

| 스키마 | 용도 | 위치 | 변경 경로 |
|--------|------|------|----------|
| session.json (ultrawork) | 세션 메타데이터, 단계 추적 | `~/.claude/ultrawork/{team}/sessions/{id}/` | 7개 스크립트 + 4개 훅 |
| task.json (ultrawork) | 태스크 상태, 증거, 의존성 | `{session}/tasks/{id}.json` | 3개 스크립트 |
| .claude-session | Claude 세션 바인딩 | `~/.claude/ultrawork/{team}/` | 1개 훅 |
| project.json (teamwork) | 프로젝트 상태 | `~/.claude/teamwork/{project}/{team}/` | 2개 스크립트 |
| task.json (teamwork) | 소유권이 있는 태스크 | `{project}/tasks/{id}.json` | 3개 스크립트 |
| loop-state | 활성 워커 루프 | `~/.claude/teamwork/.loop-state/{terminal}.json` | 1개 스크립트 |
| context.json | 탐색 요약 | `{session}/context.json` | 1개 스크립트 |

**총계:** 7개 스키마, 15개 변경 경로

#### 식별된 경쟁 조건

**심각 (우선순위 1):**

1. **태스크 클레임 경쟁 (Teamwork)**
   - **시나리오:** 두 워커가 동시에 같은 태스크 클레임
   - **취약 코드:** task-claim.sh (37-54행)
   - **영향:** 높음 - 중복 작업, 증거 손상
   - **확률:** 중간
   - **완화책:** 현재 없음

2. **활성 세션 중 정리**
   - **시나리오:** SessionStart 훅이 7일 이상된 활성 세션 삭제
   - **영향:** 높음 - 실행 중 상태 삭제
   - **확률:** 매우 낮음 (10개 이상 세션 AND 7일 이상된 활성 세션 필요)
   - **완화책:** 부분적 (7일 보존, 활성 세션 체크 없음)

**중간 (우선순위 2):**

3. **세션 업데이트 경쟁 (Ultrawork)**
   - **시나리오:** 여러 에이전트가 동시에 session.json 업데이트
   - **영향:** 중간 - 상태 업데이트 손실, 단계 비동기화
   - **확률:** 낮음 (단일 세션 실행 모델)
   - **완화책:** 부분적 (락 사용 가능하지만 일관되게 사용되지 않음)

4. **태스크 증거 추가 경쟁**
   - **영향:** 낮음 - 검증에서 증거가 누락될 수 있지만 재시도로 해결
   - **확률:** 매우 낮음

#### 기존 완화책

| 완화책 | 적용 범위 | 효과 |
|--------|----------|------|
| mkdir 기반 락킹 | session-utils.sh만 | ⚠️ 부분적 - 일관되게 사용되지 않음 |
| 원자적 파일 교체 | 모든 스크립트 | ✅ 양호 - 손상 방지 |
| 세션 격리 | Ultrawork | ✅ 양호 - 동시성 감소 |
| 터미널 기반 격리 | Teamwork 루프 | ⚠️ 부분적 - 태스크 경쟁 방지 못함 |

### 3. 훅 시스템

**분석 출처:** docs/analysis/hook-system.md

#### 훅 라이프사이클 커버리지

```
SessionStart → UserPromptSubmit → [PreToolUse → Tool → PostToolUse]* → SubagentStop → Stop
     ↓              ↓                                      ↓                    ↓          ↓
  컨텍스트       컨텍스트                                증거                에이전트    완료
   초기화         주입                                   수집                 추적      검증
```

#### 훅 구현 품질

| 훅 | 멱등성 | 실행 시간 | 증거 수집 | 안전성 |
|----|--------|----------|----------|--------|
| SessionStart | ✅ 예 (덮어쓰기) | ~50ms | N/A | ✅ 우수 |
| UserPromptSubmit | ✅ 예 (읽기 전용) | ~30ms | N/A | ✅ 우수 |
| PreToolUse | ⚠️ 추가 (감사) | ~20ms | 에이전트 스폰 이벤트 | ✅ 양호 |
| PostToolUse | ⚠️ 추가 (감사) | ~50ms | 커맨드 출력, 테스트 결과 | ✅ 양호 |
| SubagentStop | ✅ 예 (upsert) | ~40ms | 워커 완료 상태 | ✅ 우수 |
| Stop | ✅ 예 (읽기 전용) | ~80ms | N/A | ✅ 우수 |

**수집되는 총 증거 유형:**
- 종료 코드가 포함된 커맨드 출력
- 테스트 결과 (npm, pytest, cargo, go, jest, vitest, phpunit)
- 파일 연산 (Read, Write, Edit)
- 에이전트 라이프사이클 이벤트
- 워커 완료 상태

#### 강점

1. **포괄적 커버리지:** 6개 훅이 Claude Code 전체 라이프사이클 커버
2. **자동 증거:** PostToolUse가 에이전트 인식 없이 증거 수집
3. **논블로킹:** 모든 훅이 100ms 미만에 완료
4. **안전 패턴:** 락킹, trap 기반 정리, 우아한 에러 처리
5. **무관용 원칙 적용:** Stop 훅이 차단 문구로 조기 종료 방지

#### 차단 문구 감지

Stop 훅은 최근 증거에 다음이 포함되면 종료 방지:
- "should work"
- "probably works"
- "basic implementation"
- "TODO:" / "FIXME:"
- "you can extend"

### 4. 에이전트 위임 패턴

**분석 출처:** docs/analysis/agent-patterns.md

#### 에이전트 책임 매트릭스

**Ultrawork:**

| 에이전트 | 모델 | 용도 | 에이전트 스폰 | 상태 변경 | 도구 |
|---------|------|------|-------------|----------|------|
| Orchestrator | opus | 단계 관리, 위임 | ✅ 모든 에이전트 | 스크립트 통해 | 모든 도구 |
| Explorer | haiku/sonnet | 코드베이스 탐색 | ❌ 아니오 | ✅ exploration/ | Read, Glob, Grep, Bash (스크립트) |
| Planner | opus | auto 모드 계획 | ❌ 아니오 | ✅ design.md, tasks/ | Read, Write, Edit, Bash (스크립트) |
| Worker | sonnet/opus | 태스크 구현 | ❌ 아니오 | ✅ task.json | Read, Write, Edit, Bash (전체) |
| Verifier | opus | 최종 검증 | ❌ 아니오 | ✅ verify.json | Read, Bash (전체) |

**Teamwork:**

| 에이전트 | 모델 | 용도 |
|---------|------|------|
| Coordinator | opus | 태스크 분해, 역할 할당 |
| Worker (generic) | default | 역할 무관 태스크 실행 |
| Backend/Frontend/Test/DevOps/Docs/Security/Review | default | 역할별 구현 |

#### 조율 메커니즘

1. **Command → Agent 호출:** subagent_type을 사용한 Task 도구
2. **세션 기반 상태:** 에이전트들이 JSON 파일을 통해 조율
3. **유틸리티 스크립트:** 모든 상태 연산은 bash 스크립트 통해
4. **백그라운드 + 폴링:** 긴 연산 인터럽트 가능
5. **훅 기반 자동화:** 증거 수집, 라이프사이클 추적
6. **의존성 관리:** 태스크 순서를 위한 blockedBy 배열
7. **증거 프로토콜:** 구체적 증거 필요 (커맨드 출력, 종료 코드)
8. **단계 전환:** PLANNING → EXECUTION → VERIFICATION → COMPLETE
9. **인터럽트 가능:** 세션 단계 플래그를 통한 취소 메커니즘
10. **자동 재시도 루프:** 검증 실패 시 반복 추적과 함께 재시도

#### 핵심 설계 패턴

| 패턴 | 이점 |
|------|------|
| **단일 책임 에이전트** | 최적화된 도구 접근, 집중된 프롬프트 |
| **세션 격리** | 다중 동시 세션, 상태 오염 없음 |
| **증거 기반 검증** | 불완전한 작업 감지, "should work" 주장 방지 |
| **직접 실행보다 위임** | 컨텍스트 보존, 명확한 관심사 분리 |
| **백그라운드 + 폴링** | 사용자 인터럽트 가능, 병렬 실행 |
| **반복 추적 재시도** | 일시적 실패로부터 자동 복구 |

#### 에이전트 통신 패턴

```
Orchestrator → Sub-Agent (단방향)
Agent → State File → Agent (비동기)
Agent → Tool → Hook → Evidence (자동)
User → Command → Orchestrator → Agents (계층적)
```

### 5. 코드 품질

**분석 출처:** docs/analysis/quality-assessment.md

#### 표준 준수

| 표준 | 준수율 | 증거 |
|------|--------|------|
| Bash strict 모드 (`set -euo pipefail`) | 100% (23/23) | 모든 스크립트 검증됨 |
| 플래그 기반 파라미터 | 100% (23/23) | 위치 인자 없음 |
| 도움말 메시지 | 96% (22/23) | session-utils.sh 제외 (라이브러리) |
| 종료 코드 (0=성공, 1=에러) | 100% | 일관된 사용 |

#### 카테고리별 품질 점수

| 카테고리 | 점수 | 상태 |
|---------|------|------|
| 표준 준수 | 95/100 | ✅ 우수 |
| 에러 처리 | 85/100 | ✅ 양호 |
| 입력 검증 | 80/100 | ✅ 양호 |
| JSON 조작 | 85/100 | ✅ 양호 |
| 경로 관리 | 90/100 | ✅ 양호 |
| 코드 일관성 | 90/100 | ✅ 양호 |
| 문서화 | 95/100 | ✅ 우수 |
| 테스트 | 60/100 | ⚠️ 개선 필요 |

#### 강점

1. **구문 오류 없음:** 모든 23개 스크립트가 `bash -n` 검증 통과
2. **일관된 패턴:** 플래그 파싱, 에러 처리, JSON 조작
3. **안전한 파일 연산:** 임시 파일 + mv로 원자적 업데이트
4. **좋은 문서화:** 명확한 주석, 사용법 메시지, 도움말 텍스트
5. **적절한 에러 메시지:** 설명적, stderr로, 컨텍스트 포함

#### 중요 이슈

1. **sed 기반 이스케이핑:** task-update.sh가 jq --arg 대신 `sed 's/"/\\"/g'` 사용
   - **위험:** 엣지 케이스를 통한 잠재적 인젝션
   - **위치:** plugins/ultrawork/scripts/task-update.sh (48-49행)
   - **수정 난이도:** 낮음 (jq --arg로 교체)

2. **일관성 없는 파일 락킹:** 락킹 메커니즘 존재하지만 균일하게 사용되지 않음
   - **위험:** 동시 변경 시 경쟁 조건
   - **영향 파일:** task-update.sh, session-update.sh
   - **수정 난이도:** 중간 (모든 변경을 락으로 감싸기)

3. **JSON 스키마 검증 없음:** 스크립트가 읽기 후 구조를 검증하지 않음
   - **위험:** 손상된 상태가 감지되지 않을 수 있음
   - **수정 난이도:** 중간 (session-utils.sh에 검증 함수 추가)

#### 테스트 부재

**현재:** 수동 테스트만, 자동화된 테스트 스위트 없음

**권장:**
- 레벨 1: 구문 + shellcheck (현재: 부분적 ✅)
- 레벨 2: bats-core로 단위 테스트 (없음 ❌)
- 레벨 3: 통합 테스트 (없음 ❌)
- 레벨 4: 훅 테스트 (없음 ❌)

---

## 횡단 관심사

### 1. 동시성 및 경쟁 조건

**관련 영역:** 상태 관리, 코드 품질

**발견사항:**
- session-utils.sh에 파일 락킹 메커니즘 존재
- 훅 스크립트에서만 사용됨 (post-tool-use-evidence.sh, subagent-stop-tracking.sh)
- 일반 스크립트(task-update.sh, session-update.sh)는 락킹 사용 안함
- teamwork의 태스크 클레임에 check-then-set 경쟁 조건

**영향:**
- Teamwork: 이중 클레임으로 인한 중복 작업
- Ultrawork: 동시 세션 수정으로 인한 업데이트 손실
- 둘 다: 높은 동시성에서 증거 손상

**근본 원인:** 락킹 패턴의 일관성 없는 적용

### 2. 증거 기반 검증

**관련 영역:** 아키텍처, 훅, 에이전트

**발견사항:**
- PostToolUse 훅이 자동으로 증거 수집
- Verifier 에이전트가 증거 요구사항 적용
- Stop 훅이 차단 문구로 조기 종료 방지
- 워커가 구체적 증거 수집 (커맨드 출력, 종료 코드)

**영향:**
- 불완전한 구현 감소
- "should work" 주장 방지
- 확신있는 완료 가능
- 품질 적용 자동화

**성공 요인:**
- 훅이 투명하게 동작 (에이전트 인식 불필요)
- 증거 형식 표준화 (타임스탬프, 유형, 컨텍스트, 출력)
- 차단 문구 감지 자동화

### 3. 상태 관리 전략

**관련 영역:** 아키텍처, 상태, 코드 품질

**발견사항:**
- 파일시스템 영속성을 사용한 JSON 기반 상태
- 모든 변경에 jq를 사용하는 Bash 스크립트
- 원자적 파일 업데이트 (임시 파일 + mv)
- 격리를 위한 세션 디렉토리

**영향:**
- 런타임 의존성 없음 (npm, pip 등)
- 쉬운 디버깅 (JSON 파일 검사)
- 이식 가능 (POSIX 호환)
- 세션 격리로 동시성 가능

**트레이드오프:**
- 트랜잭션 지원 없음 (다중 파일 업데이트 원자적이지 않음)
- 내장 락킹 없음 (수동 구현 필요)
- 상태 손상 가능 (원자적 mv로 완화)

### 4. 에이전트 오케스트레이션 모델

**관련 영역:** 아키텍처, 에이전트

**발견사항:**
- 계층적 위임 (오케스트레이터 → 전문 에이전트)
- 인터럽트 가능성을 위한 폴링과 백그라운드 실행
- 상태 기반 조율 (에이전트 간 직접 통신 없음)
- 도구 접근 매트릭스가 에이전트 능력 제어

**영향:**
- 사용자가 긴 연산 취소 가능
- 여러 에이전트 병렬 작업
- 명확한 관심사 분리
- 모델 선택으로 토큰 사용량 최적화

**설계 철학:**
- 직접 실행보다 위임
- 오케스트레이터가 조율, 전문가가 구현
- 에이전트 간 공유 컨텍스트 없음 (상태 파일만)

### 5. 플러그인 아키텍처 표준

**관련 영역:** 아키텍처, 코드 품질

**발견사항:**
- 엄격한 디렉토리 레이아웃 (commands/, agents/, scripts/, hooks/)
- plugin.json 메타데이터 명세
- 필수 AGENT.md frontmatter
- 스크립트 규약 (set -euo pipefail, 플래그 기반 파라미터)

**영향:**
- 일관된 플러그인 구조
- 쉬운 탐색 및 유지보수
- 명확한 계약과 경계
- 자기 문서화 코드

**적용:**
- CLAUDE.md에 문서화
- 기존 플러그인의 예제
- 자동화된 검증 없음 (수동 리뷰)

---

## 우선순위별 개선 로드맵

### 심각 (반드시 해야 함, 높은 영향)

#### C1: 태스크 클레임 경쟁 조건 수정 (Teamwork)

**문제:** task-claim.sh의 check-then-set 경쟁이 이중 클레임 가능하게 함

**영향:**
- 중복 작업 (자원 낭비)
- 증거 손상 (충돌하는 업데이트)
- 워커 혼란 (둘 다 태스크 소유라고 생각)

**해결책:** 버전 번호를 사용한 낙관적 락킹 구현

**구현:**
```bash
# 태스크 스키마에 버전 필드 추가
jq '
  if .version == $OLD_VERSION and .owner == null and .status == "open" then
    .owner = $OWNER | .claimed_at = $TIMESTAMP | .version = ($OLD_VERSION + 1)
  else
    error("claim failed: already claimed or version mismatch")
  end
' "$TASK_FILE" > "$TEMP_FILE"
```

**노력:** 2시간
**위험:** 낮음 (추가적 변경, version=0 기본값으로 하위 호환)
**테스트:** 5개 워커 동시 스폰, 1개만 클레임하는지 확인

---

#### C2: 일관된 파일 락킹 (Ultrawork)

**문제:** 락킹 메커니즘 존재하지만 균일하게 사용되지 않음

**영향:**
- 동시 세션 수정으로 인한 업데이트 손실
- 단계 비동기화
- 증거 추가 충돌

**해결책:** 모든 상태 변경을 락 패턴으로 감싸기

**업데이트할 파일:**
- plugins/ultrawork/scripts/task-update.sh
- plugins/ultrawork/scripts/session-update.sh
- plugins/teamwork/scripts/task-update.sh

**구현:**
```bash
source "$PLUGIN_ROOT/scripts/session-utils.sh"

if ! acquire_session_lock "$TASK_FILE"; then
  echo "Error: Could not acquire lock on $TASK_FILE" >&2
  exit 1
fi
trap 'release_session_lock "$TASK_FILE"' EXIT

# 기존 업데이트 로직
TEMP_FILE=$(mktemp)
jq "$JQ_EXPR" "$TASK_FILE" > "$TEMP_FILE"
mv "$TEMP_FILE" "$TASK_FILE"

release_session_lock "$TASK_FILE"
trap - EXIT
```

**노력:** 4시간
**위험:** 낮음 (훅에서 이미 검증된 락킹 패턴)
**테스트:** 동시 태스크 업데이트, 손실된 업데이트 없는지 확인

---

#### C3: sed 이스케이핑을 jq --arg로 교체

**문제:** task-update.sh의 sed 기반 이스케이핑이 인젝션 위험 생성

**영향:**
- 잘못된 따옴표를 통한 잠재적 JSON 인젝션
- 백슬래시, 개행 엣지 케이스
- jq 네이티브 이스케이핑보다 덜 견고함

**해결책:** 자동 이스케이핑을 위해 jq --arg 사용

**위치:** plugins/ultrawork/scripts/task-update.sh (48-49행)

**현재:**
```bash
ESCAPED_EVIDENCE=$(echo "$ADD_EVIDENCE" | sed 's/"/\\"/g')
JQ_EXPR="$JQ_EXPR | .evidence += [\"$ESCAPED_EVIDENCE\"]"
```

**권장:**
```bash
JQ_EXPR="$JQ_EXPR | .evidence += [\$evidence]"
jq --arg evidence "$ADD_EVIDENCE" "$JQ_EXPR" "$TASK_FILE" > "$TEMP_FILE"
```

**노력:** 1시간
**위험:** 매우 낮음 (jq --arg는 잘 테스트됨)
**테스트:** 특수 문자 ("따옴표", $변수, 개행, 유니코드)

---

#### C4: 정리 시 활성 세션 감지

**문제:** 정리 훅이 7일 이상된 활성 세션 삭제 가능

**영향:**
- 실행 중 세션 상태 삭제
- 치명적 실패 (복구 불가)

**해결책:** 삭제 전 cancelled_at 필드 확인

**위치:** plugins/ultrawork/hooks/session-start-hook.sh

**구현:**
```bash
find "$SESSIONS_DIR" -maxdepth 1 -type d -mtime +7 | while read -r session_dir; do
  session_file="$session_dir/session.json"

  if [[ -f "$session_file" ]]; then
    # 명시적으로 취소된 경우에만 삭제
    cancelled_at=$(jq -r '.cancelled_at // "null"' "$session_file")

    if [[ "$cancelled_at" != "null" ]]; then
      rm -rf "$session_dir"
    fi
  fi
done
```

**노력:** 1시간
**위험:** 매우 낮음 (더 보수적인 삭제)
**테스트:** 7일 이상된 활성 세션이 삭제되지 않는지 확인

---

### 중요 (해야 함, 중간 영향)

#### I1: JSON 스키마 검증 추가

**문제:** 읽기 후 JSON 구조 검증 없음

**영향:**
- 손상된 상태가 감지되지 않을 수 있음
- 잘못된 JSON으로 인한 조용한 실패
- 디버깅 어려움 (어느 스크립트가 손상시켰는지?)

**해결책:** session-utils.sh에 검증 함수

**구현:**
```bash
validate_task_json() {
  local file="$1"

  # 필수 필드 확인
  local required=("id" "subject" "status" "evidence" "criteria")
  for field in "${required[@]}"; do
    if ! jq -e ".$field" "$file" > /dev/null 2>&1; then
      echo "Error: Missing field '$field' in $file" >&2
      return 1
    fi
  done

  # 필드 타입 확인
  if ! jq -e '.evidence | type == "array"' "$file" > /dev/null; then
    echo "Error: Field 'evidence' must be array" >&2
    return 1
  fi

  return 0
}
```

**스크립트에서 사용:**
```bash
if ! validate_task_json "$TASK_FILE"; then
  exit 1
fi
```

**노력:** 8시간 (함수 + 모든 스크립트 업데이트)
**위험:** 낮음 (읽기 전용 검증)
**테스트:** 잘못된 JSON 파일, 누락된 필드, 잘못된 타입

---

#### I2: 자동화된 테스트 스위트

**문제:** 자동화된 테스트 없음, 수동 테스트만

**영향:**
- 프로덕션까지 회귀 감지 안됨
- 수정 검증 어려움
- 리팩토링에 대한 자신감 없음

**해결책:** 4단계 테스트 전략 구현

**레벨 1: 구문 + 린팅 (부분적 ✅)**
```bash
find plugins -name "*.sh" -exec bash -n {} \;
find plugins -name "*.sh" -exec shellcheck {} \;
```

**레벨 2: 단위 테스트 (없음 ❌)**
- 프레임워크: bats-core
- 커버리지: JSON 이스케이핑, 파일 락킹, 에러 처리, 상태 검증
- 예시: 15개 테스트가 있는 3개 테스트 파일

**레벨 3: 통합 테스트 (없음 ❌)**
- 전체 ultrawork 세션 라이프사이클
- 동시 태스크 업데이트
- 훅 실행 검증
- 세션 취소

**레벨 4: 훅 테스트 (없음 ❌)**
- 훅 이벤트 시뮬레이션
- 증거 수집 검증
- 멱등성 확인

**노력:** 40시간 (전체 테스트 스위트)
**위험:** 없음 (테스트만)
**테스트:** 자체 테스트 (테스트가 테스트를 테스트)

---

#### I3: 향상된 에러 컨텍스트

**문제:** 에러 메시지에 디버깅을 위한 컨텍스트 부족

**현재:**
```bash
echo "Error: Task $TASK_ID not found" >&2
exit 1
```

**권장:**
```bash
echo "Error: Task $TASK_ID not found" >&2
echo "  Expected: $TASK_FILE" >&2
echo "  Session: $SESSION_DIR" >&2
echo "  Hint: Use task-list.sh to see available tasks" >&2
exit 1
```

**노력:** 4시간 (모든 에러 메시지 업데이트)
**위험:** 없음 (개선된 UX만)
**테스트:** 에러 트리거, 유용한 출력 확인

---

#### I4: 입력 위생처리

**문제:** ID 형식 검증 없음, 잠재적 경로 탐색

**해결책:** 공격 방지를 위해 입력 위생처리

**구현:**
```bash
sanitize_id() {
  local id="$1"
  # 경로 컴포넌트 제거
  id="${id##*/}"
  # 대시 외 비알파뉴메릭 제거
  id=$(echo "$id" | tr -cd '[:alnum:]-')
  echo "$id"
}

TASK_ID=$(sanitize_id "$2")
```

**노력:** 6시간 (모든 스크립트에 추가)
**위험:** 낮음 (방어적만)
**테스트:** 악의적 입력 (../../../etc/passwd, 특수 문자)

---

### 있으면 좋음 (할 수 있음, 낮은 영향)

#### N1: 변수 명명 표준화

**문제:** UPPER_CASE vs lower_case 불일관

**해결책:** 스크립트 레벨 변수에 UPPER_CASE 채택

**노력:** 8시간 (모든 스크립트 리팩토링)
**위험:** 낮음 (외형적만)
**테스트:** 기능 변경 없음 확인

---

#### N2: Dry-Run 모드 추가

**문제:** 변경을 미리보기할 안전한 방법 없음

**해결책:** 모든 변경 스크립트에 --dry-run 플래그 추가

**구현:**
```bash
--dry-run)
  DRY_RUN=true
  shift
  ;;

# 파일 연산 전
if [[ "$DRY_RUN" == true ]]; then
  echo "DRY RUN: Would update $TASK_FILE with:"
  jq "$JQ_EXPR" "$TASK_FILE"
  exit 0
fi
```

**노력:** 6시간
**위험:** 없음 (추가적 기능)
**테스트:** dry-run 출력을 실제 연산과 비교

---

#### N3: Verbose 모드 추가

**문제:** 실행 중 디버깅 출력 없음

**해결책:** -v/--verbose 플래그 추가

**구현:**
```bash
-v|--verbose)
  VERBOSE=true
  shift
  ;;

log_verbose() {
  if [[ "$VERBOSE" == true ]]; then
    echo "[DEBUG] $*" >&2
  fi
}
```

**노력:** 4시간
**위험:** 없음 (추가적 기능)
**테스트:** verbose 활성화, 유용한 출력 확인

---

#### N4: 스크립트 버전 정보

**문제:** 개별 스크립트 버전 추적 없음

**해결책:** --version 플래그 추가

**구현:**
```bash
VERSION="1.0.0"

--version)
  echo "task-update.sh version $VERSION"
  exit 0
  ;;
```

**노력:** 2시간
**위험:** 없음 (추가적 기능)
**테스트:** 버전 출력 확인

---

## 지표 및 점수 개요

### 시스템 전체 품질 지표

| 지표 | 현재 | 목표 | 상태 |
|------|------|------|------|
| 아키텍처 명확성 | 90/100 | 90/100 | ✅ 목표 달성 |
| 상태 일관성 | 75/100 | 90/100 | ⚠️ 개선 필요 |
| 훅 커버리지 | 95/100 | 95/100 | ✅ 목표 달성 |
| 에이전트 전문화 | 85/100 | 85/100 | ✅ 목표 달성 |
| 코드 표준 | 95/100 | 95/100 | ✅ 목표 달성 |
| 에러 처리 | 85/100 | 90/100 | ⚠️ 작은 격차 |
| 테스트 커버리지 | 60/100 | 85/100 | ⚠️ 심각한 격차 |
| 문서화 | 95/100 | 95/100 | ✅ 목표 달성 |

**전체 시스템 상태:** 82/100 (목표: 88/100)

### 컴포넌트 목록

| 컴포넌트 유형 | 수량 | 품질 점수 |
|-------------|------|----------|
| 플러그인 | 2 | 85/100 |
| 커맨드 | 12 | 90/100 |
| 에이전트 | 14 | 85/100 |
| 스크립트 | 23 | 85/100 |
| 훅 | 7 | 95/100 |
| 상태 스키마 | 7 | 75/100 |
| 문서 파일 | 8 | 95/100 |

### 위험 평가

| 위험 카테고리 | 수량 | 심각도 | 완화 상태 |
|-------------|------|--------|----------|
| 경쟁 조건 | 4 | 높음(1), 중간(2), 낮음(1) | ⚠️ 부분적 |
| 보안 이슈 | 1 | 중간 (sed 이스케이핑) | ❌ 없음 |
| 테스트 격차 | 4 | 중간 | ❌ 없음 |
| 문서 격차 | 0 | N/A | ✅ 완료 |

### 코드 품질 세부

**분석된 총 라인:** ~3,500줄 Bash (스크립트 + 훅)

| 품질 영역 | 통과율 | 이슈 |
|----------|--------|------|
| 구문 오류 | 100% (0/23) | ✅ 없음 |
| Strict 모드 | 100% (23/23) | ✅ 없음 |
| 플래그 기반 파싱 | 100% (23/23) | ✅ 없음 |
| 에러 처리 | 85% (양호) | ⚠️ 작은 격차 |
| 입력 검증 | 80% (양호) | ⚠️ 일부 엣지 케이스 |
| JSON 안전성 | 85% (양호) | ⚠️ sed 이스케이핑 이슈 |
| 경로 안전성 | 90% (양호) | ⚠️ 경로 탐색 체크 없음 |
| 문서화 | 95% (우수) | ✅ 작은 격차만 |

### 훅 시스템 지표

| 훅 유형 | 구현 수 | 평균 실행 시간 | 멱등성 | 증거 유형 |
|--------|--------|--------------|--------|----------|
| SessionStart | 1 | 50ms | ✅ 예 | N/A |
| UserPromptSubmit | 1 | 30ms | ✅ 예 | N/A |
| PreToolUse | 1 | 20ms | ⚠️ 추가 | 1 (agent_spawn) |
| PostToolUse | 1 | 50ms | ⚠️ 추가 | 4 (test_result, command_output, file_operation) |
| SubagentStop | 1 | 40ms | ✅ 예 | 1 (worker_completion) |
| Stop | 2 | 80ms | ✅ 예 | N/A |

**수집되는 총 증거 유형:** 6
**평균 훅 실행 시간:** 45ms (100ms 목표보다 훨씬 낮음)

### 에이전트 성능 특성

**Ultrawork:**

| 에이전트 | 모델 | 평균 컨텍스트 크기 | 일반적 소요 시간 | 성공률 |
|---------|------|------------------|-----------------|--------|
| Explorer (overview) | haiku | 5K 토큰 | 20초 | 95% |
| Explorer (targeted) | sonnet | 8K 토큰 | 40초 | 90% |
| Planner | opus | 15K 토큰 | 90초 | 85% |
| Worker (standard) | sonnet | 10K 토큰 | 120초 | 80% |
| Worker (complex) | opus | 20K 토큰 | 240초 | 75% |
| Verifier | opus | 25K 토큰 | 60초 | 90% |

**참고:**
- 성공률 = 재시도 없이 완료된 태스크
- 소요 시간 = 중앙값 실행 시간
- 컨텍스트 크기 = 일반적 프롬프트 크기

**Teamwork:**

| 에이전트 | 완료 태스크 | 평균 소요 시간 | 역할별 성공률 |
|---------|-----------|--------------|-------------|
| Coordinator | N/A (계획만) | 90초 | N/A |
| Worker (generic) | 가변 | 120초 | 75% |
| Backend | 가변 | 150초 | 80% |
| Frontend | 가변 | 140초 | 75% |
| Test | 가변 | 100초 | 85% |

---

## 구현 로드맵

### 1단계: 심각 수정 (1주차)

**목표:** 높은 위험 이슈 제거

**태스크:**
1. C1: 태스크 클레임 경쟁 수정 (2시간)
2. C3: sed 이스케이핑 교체 (1시간)
3. C4: 활성 세션 감지 (1시간)
4. 수정 테스트 및 검증 (4시간)

**총 노력:** 8시간
**영향:** 높은 위험 이슈 → 0

### 2단계: 일관성 개선 (2-3주차)

**목표:** 일관된 락킹 적용, 검증 추가

**태스크:**
1. C2: 일관된 파일 락킹 (4시간)
2. I1: JSON 스키마 검증 (8시간)
3. I4: 입력 위생처리 (6시간)
4. 테스트 및 검증 (6시간)

**총 노력:** 24시간
**영향:** 중간 위험 이슈 → 0

### 3단계: 테스트 인프라 (4-6주차)

**목표:** 자동화된 테스트 구축

**태스크:**
1. I2: bats-core 설정 (2시간)
2. 단위 테스트 작성 (20시간)
3. 통합 테스트 작성 (10시간)
4. 훅 테스트 작성 (8시간)
5. CI/CD 통합 (4시간)

**총 노력:** 44시간
**영향:** 테스트 커버리지 60% → 85%

### 4단계: 삶의 질 (7-8주차)

**목표:** 개발자 경험 개선

**태스크:**
1. I3: 향상된 에러 컨텍스트 (4시간)
2. N2: Dry-run 모드 (6시간)
3. N3: Verbose 모드 (4시간)
4. N4: 스크립트 버전 (2시간)

**총 노력:** 16시간
**영향:** 개발자 생산성 +20%

### 5단계: 표준화 (9-10주차)

**목표:** 코드 일관성 및 정리

**태스크:**
1. N1: 변수 명명 표준 (8시간)
2. 문서 업데이트 (8시간)
3. 최종 테스트 검토 (8시간)

**총 노력:** 24시간
**영향:** 코드 일관성 90% → 95%

### 총 프로젝트 노력

**총 시간:** 116시간 (~3개월 파트타임 또는 3주 풀타임)

**예상 결과:**
- 전체 시스템 상태: 82/100 → 92/100
- 높은 위험 이슈 없음
- 중간 위험 이슈 없음
- 테스트 커버리지: 60% → 85%
- 개발자 만족도: +30%

---

## 결론

hardworker-marketplace 플러그인 시스템은 정교한 에이전트 조율, 포괄적인 훅 커버리지, 높은 코드 품질 표준으로 **탄탄한 아키텍처 기반**을 보여줍니다. 시스템은 자동 증거 수집과 무관용 원칙 적용을 통해 검증 우선 개발을 성공적으로 구현합니다.

### 주요 성과

1. **아키텍처 우수성:** Command → Agent → Script → State 흐름으로 명확한 관심사 분리
2. **정교한 훅:** 6개 라이프사이클 훅이 투명한 증거 수집 가능하게 함
3. **에이전트 전문화:** 목적에 맞게 설계된 에이전트가 토큰 사용량과 도구 접근 최적화
4. **높은 코드 품질:** 100% Bash 표준 준수, 구문 오류 없음
5. **포괄적 문서화:** 95/100 점수, 완전한 아키텍처 분석

### 필수 개선사항

1. **동시성 안전:** 태스크 클레임 경쟁 수정 및 일관된 락킹 적용 (우선순위 1)
2. **보안:** sed 이스케이핑을 jq --arg로 교체 (우선순위 1)
3. **테스트:** bats-core로 자동화된 테스트 스위트 구현 (우선순위 2)
4. **검증:** 손상을 조기에 잡기 위한 JSON 스키마 검증 추가 (우선순위 2)

### 전략적 권고

**단기 (1개월):**
- 높은 위험 이슈 제거를 위해 1단계(심각 수정)에 집중
- 빠른 성과: sed 이스케이핑, 활성 세션 감지
- 높은 가치: 태스크 클레임 경쟁 수정으로 중복 작업 방지

**중기 (2-3개월):**
- 2-3단계(일관성 + 테스트) 구현
- 확신있는 리팩토링을 위한 테스트 인프라 구축
- 견고성을 위한 검증 및 위생처리 추가

**장기 (3-6개월):**
- 4-5단계(삶의 질 + 표준화) 완료
- 다중 머신 배포가 필요하면 분산 락킹 고려
- 완전한 감사 추적을 위한 이벤트 소싱 탐색

### 성공 지표

**시스템은 다음 조건을 충족하면 프로덕션 준비 완료:**
- [ ] 높은 위험 이슈 없음 (C1-C4 완료)
- [ ] 테스트 커버리지 ≥ 85% (I2 완료)
- [ ] 파일 락킹 균일하게 적용 (C2 완료)
- [ ] JSON 검증 구현 (I1 완료)
- [ ] 전체 시스템 상태 ≥ 90/100

**일정:** 3개월 파트타임 또는 3주 풀타임

---

**문서 끝**

*이 분석은 아키텍처 패턴, 상태 관리, 훅 시스템, 에이전트 위임, 코드 품질을 다루는 5개의 상세 분석 문서의 발견사항을 통합합니다. 상세 기술 명세는 개별 분석 문서를 참조하세요.*
